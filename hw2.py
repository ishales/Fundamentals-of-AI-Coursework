##############
# Homework 2 #
##############


###################
# Read This First #
###################


# All functions that you need to modify are marked with 'EXERCISE' in their header comments.
# Do not modify astar.py
# This file also contains many helper functions. You may call any of them in your functions.


# Due to the memory limitation, the A* algorithm may crash on some hard sokoban problems if too many
# nodes are generated. Improving the quality of the heuristic will mitigate
# this problem, as it will allow A* to solve hard problems with fewer node expansions.


# Remember that most functions are not graded on efficiency (only correctness).
# Efficiency can only influence your heuristic performance in the competition (which will affect your score).


# Load the astar.py and do not modify it.
import astar
# Load the numpy package and the state is represented as a numpy array during this homework.
import numpy as np


# a_star perform the A* algorithm with the start_state (numpy array), goal_test (function), successors (function) and
# heuristic (function). a_star prints the solution from start_state to goal_state (path), calculates the number of
# generated nodes (node_generated) and expanded nodes (node_expanded), and the solution depth (len(path)-1). a_star
# also provides the following functions for printing states and moves: prettyMoves(path): Translate the solution to a
# list of moves printlists(path): Visualize the solution and Print a list of states
def a_star(start_state, goal_test, successors, heuristic):
    goal_node, node_generated, node_expanded = astar.a_star_search(start_state, goal_test, successors, heuristic)
    if goal_node:
        node = goal_node
        path = [node.state1]
        while node.parent:
            node = node.parent
            path.append(node.state1)
        path.reverse()

        print('My path:{}'.format(path))
        print(prettyMoves(path))
        printlists(path)
        print('Nodes Generated by A*: {}'.format(node_generated))
        print('Nodes Expanded by A*: {}'.format(node_expanded))
        print('Solution Depth: {}'.format(len(path) - 1))
    else:
        print('no solution found')


# A shortcut function
# Transform the input state to numpy array. For other functions, the state s is presented as a numpy array.
# Goal-test and next-states stay the same throughout the assignment
# You can just call sokoban(init-state, heuristic function) to test the result
def sokoban(s, h):
    return a_star(np.array(s), goal_test, next_states, h)


# Define some global variables
blank = 0
wall = 1
box = 2
keeper = 3
star = 4
boxstar = 5
keeperstar = 6


# Some helper functions for checking the content of a square
def isBlank(v):
    return (v == blank)


def isWall(v):
    return (v == wall)


def isBox(v):
    return (v == box)


def isKeeper(v):
    return (v == keeper)


def isStar(v):
    return (v == star)


def isBoxstar(v):
    return (v == boxstar)


def isKeeperstar(v):
    return (v == keeperstar)


# Help function for get KeeperPosition
# Given state s (numpy array), return the position of the keeper by row, col
# The top row is the zeroth row
# The first (right) column is the zeroth column
def getKeeperPosition(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            if (isKeeper(s[i, j]) or isKeeperstar(s[i, j])):
                return i, j


# For input list s_list, remove all None element
# For example, if s_list = [1, 2, None, 3], returns [1, 2, 3]
def cleanUpList(s_list):
    clean = []
    for state in s_list:
        if state is not None:
            clean.append(state)
    return clean


# EXERCISE: Modify this function to return Ture
# if and only if s (numpy array) is a goal state of a Sokoban game.
# (no box is on a non-goal square)
# Remember, the number of goal can be larger than the number of box.
# Currently, it always returns False. If A* is called with
# this function as the goal testing function, A* will never
# terminate until the whole search space is exhausted.
def goal_test(s):
    
    if np.any(s == 2):
        return False

    return True


# EXERCISE: Modify this function to return the list of
# successor states of s (numpy array).
#
# This is the top-level next-states (successor) function.
# Some skeleton code is provided below.
# You may delete them totally, depending on your approach.
# 
# If you want to use it, you will need to set 'result' to be 
# the set of states after moving the keeper in each of the 4 directions.
#
# You can define the function try-move and decide how to represent UP,DOWN,LEFT,RIGHT.
# Any None result in the list can be removed by cleanUpList.
#
# When generated the successors states, you may need to copy the current state s (numpy array).
# A shallow copy (e.g, direcly set s1 = s) constructs a new compound object and then inserts references 
# into it to the objects found in the original. In this case, any change in the numpy array s1 will also affect
# the original array s. Thus, you may need a deep copy (e.g, s1 = np.copy(s)) to construct an indepedent array.

# function to get content of square
def get_square(s, row, col):
    if isBlank(s[row, col]):
        return 0
    elif isWall(s[row, col]):
        return 1
    elif isBox(s[row, col]):
        return 2
    elif isKeeper(s[row, col]):
        return 3
    elif isStar(s[row, col]):
        return 4
    elif isBoxstar(s[row, col]):
        return 5
    elif isKeeperstar(s[row, col]):
        return 6
    else:
        return 1

# function to set square to the value of v
def set_square(s, row, col, v):
    sN = np.copy(s)
    sN[row, col] = v
    return sN


# function to check valid move
def movebox(s, r, c):
    check = get_square(s, r, c)
    if check == 0:
        return True
    if check == 1:
        return False
    if check == 2:
        return False
    if check == 4:
        return True
    if check == 5:
        return False

    return False

# function to move the keeper in the direction specified
# return None if state is invalid
def try_move(s, d):
    sc = np.copy(s)
    tr, tc = sc.shape
    rc, cc = getKeeperPosition(s)
    # replace keeper
    if (get_square(s, rc, cc) == 3):
        sc[rc, cc] = 0
    elif (get_square(s, rc, cc) == 6):
        sc[rc, cc] = 4

    if (d == 1):        # move up
        
        if rc-1 < 0:
            return None
        
        up_c = get_square(s, rc-1, cc)
        if up_c == 0:
            sc[rc-1, cc] = 3
            return sc       # move keeper up
        elif up_c == 1:
            return None     # hit a wall
        elif up_c == 2:
            if(rc - 2 < 0):
                return None
            elif(movebox(s, rc-2, cc) == False):
                return None
            else:
                abv = get_square(s, rc-2, cc)
                if abv == 0:
                    sc[rc-2, cc] = 2
                    sc[rc-1, cc] = 3
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc-2, cc] = 5
                    sc[rc-1, cc] = 3
                    return sc           # move box onto a star
        elif up_c == 4:
            sc[rc-1, cc] = 6
            return sc           # move keeper onto a star
        elif up_c == 5:
            if(rc - 2 < 0):
                return None
            elif(movebox(s, rc-2, cc) == False):
                 return None
            else:
                abv = get_square(s, rc-2, cc)
                if abv == 0:
                    sc[rc-2, cc] = 2
                    sc[rc-1, cc] = 6
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc-2, cc] = 5
                    sc[rc-1, cc] = 6
                    return sc           # move box onto a star
            
        else:
            return None     # outside of game scope

            
    elif (d == 2):      # move down
        
        if rc+1 == tr:
            return None
        
        down_c = get_square(s, rc+1, cc)
        if down_c == 0:
            sc[rc+1, cc] = 3
            return sc
        elif down_c == 1:
            return None
        elif down_c == 2:
            if(rc+2 == tr):
                return None
            elif(movebox(s, rc+2, cc) == False):
                return None
            else:
                abv = get_square(s, rc+2, cc)
                if abv == 0:
                    sc[rc+2, cc] = 2
                    sc[rc+1, cc] = 3
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc+2, cc] = 5
                    sc[rc+1, cc] = 3
                    return sc           # move box onto a star
        elif down_c == 4:
            sc[rc+1, cc] = 6
            return sc
        elif down_c == 5:
            if(rc+2 == tr):
                return None
            elif(movebox(s, rc+2, cc) == False):
                 return None
            else:
                abv = get_square(s, rc+2, cc)
                if abv == 0:
                    sc[rc+2, cc] = 2
                    sc[rc+1, cc] = 6
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc+2, cc] = 5
                    sc[rc+1, cc] = 6
                    return sc           # move box onto a star
        else:
            return None
        
        
    elif (d == 3):      # move right

        if cc - 1 < 0:
            return None
        
        right_c = get_square(s, rc, cc-1)
        if right_c == 0:
            sc[rc, cc-1] = 3
            return sc
        elif right_c == 1:
            return None
        elif right_c == 2:
            if(cc-2 < 0):
                return None
            elif(movebox(s, rc, cc-2) == False):
                return None
            else:
                abv = get_square(s, rc, cc-2)
                if abv == 0:
                    sc[rc, cc-2] = 2
                    sc[rc, cc-1] = 3
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc, cc-2] = 5
                    sc[rc, cc-1] = 3
                    return sc           # move box onto a star
        elif right_c == 4:
            sc[rc, cc-1] = 6
            return sc
        elif right_c == 5:
            if(cc-2 < 0):
                return None
            elif(movebox(s, rc, cc-2) == False):
                 return None
            else:
                abv = get_square(s, rc, cc-2)
                if abv == 0:
                    sc[rc, cc-2] = 2
                    sc[rc, cc-1] = 6
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc, cc-2] = 5
                    sc[rc, cc-1] = 6
                    return sc           # move box onto a star

        else:
            return None

        
    elif (d == 4):      # move left

        if cc+1 == tc:
            return None
        
        left_c = get_square(s, rc, cc+1)
        if left_c == 0:
            sc[rc, cc+1] = 3
            return sc
        if left_c == 1:
            return None
        elif left_c == 2:
            if(cc+2 == tc):
                return None
            elif(movebox(s, rc, cc+2) == False):
                return None
            else:
                abv = get_square(s, rc, cc+2)
                if abv == 0:
                    sc[rc, cc+2] = 2
                    sc[rc, cc+1] = 3
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc, cc+2] = 5
                    sc[rc, cc+1] = 3
                    return sc           # move box onto a star
        elif left_c == 4:
            sc[rc, cc+1] = 6
            return sc
        elif left_c == 5:
            if(cc+2 == tc):
                return None
            elif(movebox(s, rc, cc+2) == False):
                 return None
            else:
                abv = get_square(s, rc, cc+2)
                if abv == 0:
                    sc[rc, cc+2] = 2
                    sc[rc, cc+1] = 6
                    return sc           # move box up one sq
                elif abv == 4:
                    sc[rc, cc+2] = 5
                    sc[rc, cc+1] = 6
                    return sc           # move box onto a star
        else:
            return None
        

    return None         # no direction specified

def next_states(s):
    #row, col = getKeeperPosition(s)
    s_list = []
    #s1 = np.copy(s)

    up = try_move(s, 1)
    down = try_move(s, 2)
    right = try_move(s, 3)
    left = try_move(s, 4)
    
    s_list = [up, down, right, left]

    return cleanUpList(s_list)


# EXERCISE: Modify this function to compute the trivial
# admissible heuristic.
def h0(s):
    return 0


# EXERCISE: Modify this function to compute the
# number of misplaced boxes in state s (numpy array).

# This heuristic is admissible, as it will never overestimate
# the cost of reaching the goal. This heuristic will calculate
# the amount of boxes left out of place, which will never exceed
# the true cost of reaching the goal state. There will always be at
# least one move left if a box is out of place. 
def h1(s):
    count = 0
    
    count = np.sum(s == 2)

    return count


# EXERCISE: Change the name of this function to h<UID> where
# <UID> is your actual student ID number. Then, modify this 
# function to compute an admissible heuristic value of s. 
# For example, if my UID is 123456789, then I should change the function name to 'h123456789'
# This function will be tested in various hard examples.
# Objective: make A* solve problems as fast as possible.

def h305595070(s):

    r, c = s.shape
    boxes = []
    stars = []
    dist = 0

    for i in range(r):
        for j in range(c):
            squ = get_square(s, i, j)
            if(isBox(squ)):
                boxes.append((i, j))
            if(isStar(squ) or isKeeperstar(squ)):
                stars.append((i,j))

    for a in range(len(boxes)):
        cb = boxes[a]
        cb_dis = []
        for b in range(len(stars)):
            cs = stars[b]
            xd = cs[0] - cb[0]
            yd = cs[1] - cb[1]
            fin = xd + yd
            add_f = abs(fin)
            cb_dis.append(add_f)

        min_d = min(cb_dis)
        dist += min_d
        min_index = cb_dis.index(min_d)
        stars.pop(min_index)
    
    return dist


# Some predefined problems with initial state s (array). Sokoban function will automatically transform it to numpy
# array. For other function, the state s is presented as a numpy array. You can just call sokoban(init-state,
# heuristic function) to test the result Each problem can be visualized by calling prettyMoves(path) and printlists(
# path) in a_star function
#
# Problems are roughly ordered by their difficulties.
# For most problems, we also provide 2 additional number per problem:
#    1) # of nodes expanded by A* using our next-states and h0 heuristic.
#    2) the depth of the optimal solution.
# These numbers are located at the comments of the problems. For example, the first problem below 
# was solved by 80 nodes expansion of A* and its optimal solution depth is 7.
# 
# Your implementation may not result in the same number of nodes expanded, but it should probably
# give something in the same ballpark. As for the solution depth, any admissible heuristic must 
# make A* return an optimal solution. So, the depths of the optimal solutions provided could be used
# for checking whether your heuristic is admissible.
#
# Warning: some problems toward the end are quite hard and could be impossible to solve without a good heuristic!


# [80,7]
s1 = [[1, 1, 1, 1, 1, 1],
      [1, 0, 3, 0, 0, 1],
      [1, 0, 2, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]


# [110,10],
s2 = [[1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 2, 1, 4, 1],
      [1, 3, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 1]]

# [211,12],
s3 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 2, 0, 3, 4, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [300,13],
s4 = [[1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 1, 4],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 0, 0, 0, 0],
      [0, 2, 1, 0, 0, 0, 0],
      [0, 3, 1, 0, 0, 0, 0]]

# [551,10],
s5 = [[1, 1, 1, 1, 1, 1],
      [1, 1, 0, 0, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 4, 2, 2, 4, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 1, 3, 1, 1, 1],
      [1, 1, 1, 1, 1, 1]]

# [722,12],
s6 = [[1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 4, 1],
      [1, 0, 0, 0, 2, 2, 3, 1],
      [1, 0, 0, 1, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1, 1, 1]]

# [1738,50],
s7 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 1, 0, 0, 0, 3],
      [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      [0, 2, 1, 0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 0, 0, 0, 1, 4]]

# [1763,22],
s8 = [[1, 1, 1, 1, 1, 1],
      [1, 4, 0, 0, 4, 1],
      [1, 0, 2, 2, 0, 1],
      [1, 2, 0, 1, 0, 1],
      [1, 3, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [1806,41],
s9 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 0, 0, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 2, 0, 1],
      [1, 0, 1, 0, 0, 1, 2, 0, 1],
      [1, 0, 4, 0, 4, 1, 3, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [10082,51],
s10 = [[1, 1, 1, 1, 1, 0, 0],
       [1, 0, 0, 0, 1, 1, 0],
       [1, 3, 2, 0, 0, 1, 1],
       [1, 1, 0, 2, 0, 0, 1],
       [0, 1, 1, 0, 2, 0, 1],
       [0, 0, 1, 1, 0, 0, 1],
       [0, 0, 0, 1, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 1, 1]]

# [16517,48],
s11 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 4, 1],
       [1, 0, 2, 2, 1, 0, 1],
       [1, 0, 2, 0, 1, 3, 1],
       [1, 1, 2, 0, 1, 0, 1],
       [1, 4, 0, 0, 4, 0, 1],
       [1, 1, 1, 1, 1, 1, 1]]

# [22035,38],
s12 = [[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
       [1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1],
       [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 2, 1, 1, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 1, 0, 1, 4, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]]

# [26905,28],
s13 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 2, 0, 1],
       [1, 0, 2, 0, 0, 0, 0, 0, 4, 1],
       [1, 0, 3, 0, 0, 0, 0, 0, 2, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [41715,53],
s14 = [[0, 0, 1, 0, 0, 0, 0],
       [0, 2, 1, 4, 0, 0, 0],
       [0, 2, 0, 4, 0, 0, 0],
       [3, 2, 1, 1, 1, 0, 0],
       [0, 0, 1, 4, 0, 0, 0]]

# [48695,44],
s15 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 2, 2, 0, 1],
       [1, 0, 2, 0, 2, 3, 1],
       [1, 4, 4, 1, 1, 1, 1],
       [1, 4, 4, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0]]

# [91344,111],
s16 = [[1, 1, 1, 1, 1, 0, 0, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [1, 2, 1, 0, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 5, 0, 5, 0, 1],
       [1, 0, 5, 0, 1, 0, 1, 1],
       [1, 1, 1, 0, 3, 0, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 0]]

# [3301278,76],
# Warning: This problem is very hard and could be impossible to solve without a good heuristic!
s17 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 3, 0, 0, 1, 0, 0, 0, 4, 1],
       [1, 0, 2, 0, 2, 0, 0, 4, 4, 1],
       [1, 0, 2, 2, 2, 1, 1, 4, 4, 1],
       [1, 0, 0, 0, 0, 1, 1, 4, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]

# [??,25],
s18 = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 4, 1, 0, 0, 0, 0]]

# [??,21],
s19 = [[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 4],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 2, 0, 4, 1, 0, 0, 0]]


# Utility functions for printing states and moves.
# You do not need to understand any of the functions below this point.


# Helper function of prettyMoves
# Detect the move from state s --> s1
def detectDiff(s, s1):
    row, col = getKeeperPosition(s)
    row1, col1 = getKeeperPosition(s1)
    if (row1 == row + 1):
        return 'Down'
    if (row1 == row - 1):
        return 'Up'
    if (col1 == col + 1):
        return 'Right'
    if (col1 == col - 1):
        return 'Left'
    return 'fail'


# Translates a list of states into a list of moves
def prettyMoves(lists):
    initial = 0
    action = []
    for states in (lists):
        if (initial != 0):
            action.append(detectDiff(previous, states))
        initial = 1
        previous = states
    return action


# Print the content of the square to stdout.
def printsquare(v):
    if (v == blank):
        print(' ', end='')
    if (v == wall):
        print('#', end='')
    if (v == box):
        print('$', end='')
    if (v == keeper):
        print('@', end='')
    if (v == star):
        print('.', end='')
    if (v == boxstar):
        print('*', end='')
    if (v == keeperstar):
        print('+', end='')


# Print a state
def printstate(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            printsquare(s[i, j])
        print('\n')


# Print a list of states with delay.
def printlists(lists):
    for states in (lists):
        printstate(states)
        print('\n')


if __name__ == "__main__":
    sokoban(s1, h305595070)

    sokoban(s18, h305595070)

    #sokoban(s3, h305595070)

    #sokoban(s4, h305595070)

